상속관계
: 관계형 데이터베이스는 상속 관계X

ex)
Item
<- movie
<- book
<- album

주요 어노테이션
@Inheritance(strategy=InheritanceType.XXX) 
: JOINED: 조인 전략(자식테이블에 PK,FK가 한 컬럼으로 들어감)
: SINGLE_TABLE: 단일 테이블 전략(한 테이블에 다 들어감)
: TABLE_PER_CLASS: 구현 클래스마다 테이블 전략(item을 없애고 item속성을 중복되게 자식으로 다 내림 item클래스를 추상클래스로 해줘야함)

@DiscriminatorColumn(name=“DTYPE”) 
@DiscriminatorValue(“XXX”)
: item클래스에 @DiscriminatorColumn(name = "DTYPE")을 넣으면
: item테이블에 구분을 위한? DTYPE 컬럼하나를 넣는다
: 자식 클래스명(엔티티명)으로 들어간다 Movie, Book, album
: 자식 클래스에서 따로 @DiscriminatorValue("")를 해주면
: 따로 이름을 지정할 수 있다
: 꼭 넣어주도록 하자



@MappedSuperclass
: 공통 매핑 정보가 필요할 때 사용(create_dt, update_dt 등)
:
: @MappedSuperclass
: class BaseEntity {
:    private LocalDateTime createDt;
:    private LocalDateTime updateDt;
: }
: class Member extends BaseEntity
:
: 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
: 조회, 검색 불가(em.find(BaseEntity) 불가)
: 추상 클래스 권장
: @Entity 클래스는 엔티티나 @MappedSuperclass로 지
: 정한 클래스만 상속 가능



=> 실무에서는 상속관계 매핑을 고려해봐야 한다
=> json으로 그냥 한 컬럼에다가 박을 수도 있다 어차피 DTYPE이 있으니깐 구분할 수 있따
=> 간단한 테이블이라면 상속관계를 쓰지 말고 
=> 그냥 json으로 밀어 넣는것도 좋은 방법일 듯
