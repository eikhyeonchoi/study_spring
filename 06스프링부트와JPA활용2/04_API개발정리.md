# API개발정리
```
엔티티 조회
: 엔티티를 조회해서 그대로 반환: V1
: 엔티티 조회 후 DTO로 변환: V2
: 페치 조인으로 쿼리 수 최적화: V3
: 컬렉션 페이징과 한계 돌파: V3.1
    컬렉션은 페치 조인시 페이징이 불가능
    ToOne 관계는 페치 조인으로 쿼리 수 최적화
    컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, hibernate.default_batch_fetch_size ,
    @BatchSize 로 최적화

★★★ 결론 ★★★
: ToOne이면 fetch join 후 DTO로 변환해서 리턴(권장) -> 안되면 Repository에서 DTO 반환(Repository 따로 분리할 것)
: 컬렉션(일대다)이면 fetch join을 사용하면 페이징안되기 때문에(+데이터가 뻥튀기됨) batchsize 옵션넣고 쿼리문 최적화해서 DTO 변환 후 리턴
+ 일대다를 fetch join 과 페이징을 동시에 사용하면 메모리에서 페이징해버림 -> 절대하면 안됨
+ 기대 결과 row count와 실제 query row count가 달라져 버리기 때문에 메모리에서 페이징해버리는것
+ 일대다 fetch join을 사용하더라도 1개만 사용가능

DTO 직접 조회
: JPA에서 DTO를 직접 조회: V4 -> 일대다는 따로 쿼리해줌(반복문으로) 다대일은 미리 join
: 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: V5(query에 in절 추가) - 페이징 안됨
: 플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환: V6 - 페이징 안됨



권장 순서
1. 엔티티 조회 방식으로 우선 접근
    1. 페치조인으로 쿼리 수를 최적화
    2. 컬렉션 최적화
        1. (페이징 필요 + 데이터 뻥튀기 방지) -> hibernate.default_batch_fetch_size(글로벌), @BatchSize 로 최적화 - 글로벌 권장
        2. fetch join을 사용하면 최적화는 되지만 데이터가 뻥튀기 되고 페이징이 불가능함
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate

참고: 엔티티 조회 방식은 페치 조인이나, hibernate.default_batch_fetch_size , @BatchSize 같이
코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수 있다. 반면에 DTO를
직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.

참고: 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다. 항상 그런 것은 아니지만, 보통
성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.
엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화 할 수 있다.
반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기를 해야 한다.
```