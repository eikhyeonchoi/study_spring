:::annotation 정리:::

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

컴포넌트 스캔과 자동 의존관계 설정

@ComponentScan
: 컴포넌트 스캔은 이름 그대로 @Component 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록
: 스프링 빈의 기본이름은 클래스명을 사용하되 맨 앞글자만 소문자로 바꾼다
: 직접 지정할 수 있다 @Component("abc")
: @Autowried를 사용해 DI를 완성한다
: 스프링부트로 시작한다면 @SpringBootApplication에 @ComponentScan이 붙어있다
: 스캔 범위를 직접 지정할 수 있으며, 기본은 이 어노테이션이 붙은 패키지이다 -> 보통 최상단에 두는 것이 관례


@Controller - Controller, class 에서 사용
@Service - Service, class 에서 사용
@Repository - Repository, class 에서 사용
: 스프링컨테이너에 객체를 만들어 넣는다
: 컴포넌트 스캔 방법임 -> 사실 다 @Component임 scope은 패키지임 메인패키지 하위만 스캔


@Autowried - Controller, constructor 에서 사용
: 스프링컨테이너에 있는 객체를 알아서 연결시켜줌 
: Controller - Service - Repository를 연결시켜주는 역할
: Controller는 Service가 필요하고 Service는 Repository가 필요함
: 이 annotation이 Dependancy Injection(=DI) 역할을 하는 듯
: 당연하겠지만, Spring Bean으로 등록된 객체만 Autowried가 동작한다

@Qulifier("name")
: 동일한 타입의 스프링 빈이 여러개 있을 경우 이름을 지정해서 주입할 수 있게 해줌
: 생성자 파라미터에도 붙여줘야하고 주입 되는 빈에도 적어줘야함
: @Primary보다 우선순위가 높다

@Primary
: 동일한 타입의 스프링 빈이 여러 있다면 이 어노테이션이 붙은 빈이 우선순위가 높다
: 주입되는 빈에만 적어줘도 된다 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

자바 코드로 직접 스프링 빈 등록하기

@Configuration - class에서 사용
: 스프링에 bean객체를 직접 넣고 싶을 때 사용
: 해당 어노테이션이 붙은 class를 설정 정보로 사용함
: 이 어노테이션이 스프링 컨테이너의 싱글톤을 유지시켜주는 어노테이션이다
: class에 붙여 사용하게 되는데, 스프링이 이 어노테이션이 붙은 클래스를 상속받아서
: CGLIB 기술을 사용해 상속받은 가짜 클래스를 스프링 컨테이너로 등록해서 싱글톤을 유지시켜준다
: @Bean과 같이 사용하며 @Bean 어노테이션이 붙은 메서드를 모두 호출해서 컨테이너 등록함(key: 메서드명, value: 객체)


@Bean - 메서드에 사용
: 스프링컨테이너에 객체를 직접 넣고 싶을 때 사용한다
: 해당 어노테이션이 붙은 메서드를 컨테이너가 호출해 객체를 반환받아 저장해서 관리함(key: 메서드명, value: 객체)
: 스프링 빈이라고 칭함
: 이 어노테이션이 붙은 메서드마다 메타정보를 생성한다
: 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성함
: @Configuration과 같이 사용한다

@PostConstruct, @PreDestroy
: 빈 생명주기와 관련된 어노테이션
: @PostConstruct: 의존성 주입이 시작되고 호출(사용 전 호출)
: @PreDestroy: 빈이 소멸되기 전 호출

※ 스프링 빈 생명주기
컨테이너 생성 => 빈 등록 -> 의존성 주입 -> @PostConstruct -> 사용 -> @PreDestroy -> 소멸

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@RequestMapping
: http 메소드 매핑


@RequestParam
: 요청파라미터 받기


@ResponseBody - 메서드에 사용
@RestController - 클래스에 사용
: class에 붙이면 클래스 전체가 전체가 api화(?)된다
: viewResolver 대신 HttpMessageConverter를 통해 문자면 그냥 문자를 반환함, 객체라면 json으로 반환함


@SpringBootTest - 스프링 컨테이너와 테스트를 함께 실행
@Transactional - 테스트 완료 후 DB rollback을 한다(테스트 반복을 위해) 테스트 case에 붙었을때만 rollback
: 테스트 할 때 사용할 anno(@Transactional은 다른곳에서도 사용한다)


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

JPA

@Entity - domain, class에 사용
: jpa가 관리하는 객체로 설정


@Id - domain 인스턴스 필드에 설정
: PK 설정

@Column(name = "column name") - domain 인스턴스 필드에 설정
: column 매칭
